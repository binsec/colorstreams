{0 Colorstreams API Documentation}

All libraries are wrapped into the {e Colorstreams} module:

- {{!Colorstreams.Base} [Base]}: basic functionalities and utilities
- {{!Colorstreams.Pmc} [Pmc]}: (projected) model counting solver interaction
- {{!Colorstreams.Symbolic} [Symbolic]}: symbolic execution and property verification
- {{!Colorstreams.Policies} [Policies]}: analysis policies

{1 General concepts}

{2 Memory representations}

Memory locations, registers and custom variables are represented as {e storage units} (see {{!Colorstreams.Base.Storage.t} [Base.Storage.t]}), which can be composed into {e expressions} (see {{!Colorstreams.Base.Expr.t} [Base.Expr.t]}).

{2 Sources and sinks}

Analyzed data flows originate from {e sources} (see {{!Colorstreams.Base.Source.t} [Base.Source.t]}), such program inputs. 
{e Sinks} (see {{!Colorstreams.Base.Sink.t} [Base.Sink.t]}) mark variables (storage unit expressions) to be checked, such as a return address.
For example, taint analysis consists in introducing taint tags to source variables and checking whether sink variables are tagged after propagation.

Sources and sinks can originate from tracing, in particular when they are manually set with code instrumentation, or be automatically generated by analysis policies and propagated though policy composition.

{2 Analysis policies}

Analysis policies are implemented through callbacks for executed instructions, function calls, etc...
The general framework is provided by {{!Colorstreams.Base.Analysis.Make} [Base.Analysis.Make]}.
For example, taint tag propagation for taint analysis would take place in instruction callbacks.
See the {{!Colorstreams.Base.Analysis} [Base.Analysis]} module for more details and [src/policies/basic_policy.ml] for an example of a simple taint analysis policy with symbolic-execution-based overtaint checking.

Analysis policies must be registered to the {{!Colorstreams.Policies.Policy} [Policies.Policy]} module with a module of type {{!Colorstreams.Policies.Policy.BaseSig} [BaseSig]}.
This allows policies to be handled generically rather than managed directly.
One of the main goals of {e Colorstreams} is to achieve {e analysis policy composability}, i.e., the ability to combine different analysis policies, improving versatility and expandability.
An example of this concept is the {e compose} policy ([src/policies/compose.ml]), which takes sources and sinks generated by producer analyses and feeds them to consumers.

{2 Messaging, generic results and logging}

All messages, analysis results and generated sources and sinks should be reported through the {{!Colorstreams.Base.Message} [Base.Message]} API.
This is to ensure that everything is properly logged and can be re-processed by parent analysis policies.
Message wrappers are implemented for this purpose in the {{!Colorstreams.Base.Message} [Base.Message]}, {{!Colorstreams.Base.Result} [Base.Result]} and {{!Colorstreams.Base.Analysis} [Base.Analysis]} modules.

Analysis results in particular should also follow the generic result framework from the {{!Colorstreams.Base.Result} [Base.Result]} module through the use of {{!Colorstreams.Base.Result.Make} [Result.Make]}.
It allows to properly log complex data while preserving custom data structures for parent analyses which may need them.
